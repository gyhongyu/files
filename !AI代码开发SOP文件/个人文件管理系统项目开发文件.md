# **个人文件管理系统：基于Google Drive与AI的系统架构深度解析**

为解决个人用户在Google Drive中文件繁杂、查找困难的痛点，开发一款集文件新增、修改、删除、分享及AI智能查找功能于一体的Web应用【个人文件管理系统】，无疑具有巨大的实用价值。本文将深入探讨构建此系统所需的核心架构，涵盖用户认证、前后端设计、Google Drive API集成、AI搜索实现等关键环节，为您描绘一幅清晰的技术蓝图。

### **一、 系统核心理念与架构概览**

本系统的核心理念是将用户从Google Drive原生界面的繁琐操作中解放出来，通过一个统一、直观的前端界面，结合强大的AI搜索能力，实现对个人云端文件的便捷管理。所有文件依然存储在用户自己的Google Drive中，本应用仅作为高效的管理和检索引擎，确保用户数据的安全与私有。

**系统架构将主要分为以下几个部分：**

* **前端应用 (Frontend):** 用户交互的界面，负责展示文件列表、操作文件以及提供AI搜索框。  
* **后端服务 (Backend):** 系统的核心业务逻辑，处理用户请求、与Google Drive API交互、并协调AI服务。  
* **Google Drive API:** 连接用户Google Drive的桥梁，执行所有文件操作的指令。  
* **AI服务 (AI Services):** 调用Google Gemini API，负责文件的内容提取、建立索引以及执行自然语言搜索。

\!\[系统架构图\](https://i.imgur.com/example.png "一个示例架构图，实际组件可能更复杂")

### **二、 关键技术模块详解**

#### **1\. 安全的用户认证：OAuth 2.0 授权**

要代表用户操作其Google Drive中的文件，首先必须获得用户的明确授权。这需要采用 **OAuth 2.0** 协议，这是目前最安全、最标准的授权框架。

* **授权流程:**  
  1. 当用户首次登录您的应用时，会被重定向到Google的授权页面。  
  2. 该页面会清晰地列出您的应用希望获得的权限（例如：查看、编辑、创建和删除其Google Drive中的文件）。  
  3. 用户同意授权后，Google会向您的后端服务返回一个授权码 (Authorization Code)。  
  4. 您的后端服务使用此授权码，连同应用的客户端ID和客户端密钥，向Google请求访问令牌 (Access Token) 和刷新令牌 (Refresh Token)。  
  5. **访问令牌 (Access Token)** 用于在一段时间内（通常是一小时）访问用户的Google Drive API。  
  6. **刷新令牌 (Refresh Token)** 则长期有效，用于在访问令牌过期后，自动获取新的访问令牌，避免用户需要反复授权。  
* **安全存储:** 访问令牌和刷新令牌是极其敏感的用户凭证，必须在后端进行加密存储，并严格控制访问权限。

#### **2\. 前端应用：打造流畅的用户体验**

前端是用户与系统交互的门户，应注重简洁、直观和高效。推荐使用现代化的前端框架，如 **React, Vue.js, 或 Angular**，它们能提供强大的组件化能力和良好的开发体验。

* **核心功能模块:**  
  * **文件/文件夹浏览器:** 以列表或网格视图清晰地展示用户的Google Drive文件和文件夹结构。  
  * **文件操作界面:** 提供上传、下载、重命名、移动、删除文件的直观操作按钮或菜单。  
  * **分享管理:** 允许用户方便地生成文件的分享链接，并设置不同的分享权限（查看者、评论者、编辑者）。  
  * **AI搜索栏:** 一个显眼的搜索框，支持用户输入自然语言进行文件查找。  
  * **文件预览:** 对于常见的文件类型（如PDF, 图片, 文本文档），可在前端直接预览，无需下载。  
  * **API密钥管理与模式切换:** 提供一个安全的界面，让用户输入并保存他们自己的Gemini API密钥。前端界面需要能根据用户的状态（试用期、已提供密钥、未提供密钥）动态显示或隐藏AI相关功能，并启用手动分类输入框。  
  * **安全信息库界面 (Secure Vault UI):** 提供专门的表单用于输入网站、用户名、密码等敏感信息，并引导用户设置一个“主密码”用于加密。在查看时，提供密码输入框以进行解密。

#### **3\. 后端服务：强大的业务逻辑中枢**

后端是整个系统的大脑，负责处理所有业务逻辑。可选择 **Node.js (Express), Python (Django/Flask), 或 Go** 等主流后端技术栈。

* **API端点设计:**  
  * /auth/google: 处理OAuth 2.0的认证回调。  
  * /files: 获取文件和文件夹列表。  
  * /files/upload: 处理文件上传。  
  * /files/{fileId}: 获取、修改或删除特定文件。  
  * /files/{fileId}/share: 创建和管理分享链接。  
  * /search: 接收前端的AI搜索请求。  
  * /vault/save: 接收前端发送过来的、**已经加密好**的敏感信息文件，并将其存入Google Drive。  
  * /vault/{fileId}/get: 从Google Drive获取指定的加密文件，并**原封不动地**传回给前端进行解密。  
  * /webhook/drive-changes: 接收来自Google Drive的推送通知，作为数据同步的触发器。  
* **与Google Drive API的交互:** 后端将使用Google提供的官方客户端库，通过用户授权的访问令牌，调用Google Drive API v3的各个接口，实现对文件的增删改查及分享功能。  
* **智能AI路由与用户管理:**  
  * **用户状态管理:** 数据库需清晰记录每个用户的状态（试用、BYOK、付费订阅）及其对应的用量（如试用次数）。  
  * **API密钥路由:** 后端逻辑需判断AI请求应使用我们自己的API密钥（试用/付费用户），还是用户提供的密钥（BYOK用户）。  
  * **模型选择逻辑:** 实现智能“分诊”，根据任务复杂度动态选择最合适的Gemini模型。  
* **后台任务系统:** 需要一个后台任务处理器（如Cron Job），用于执行定期的同步检查任务。

#### **4\. 数据同步：保持应用与Google Drive的一致性**

为解决用户直接在Google Drive中操作文件（反向同步）导致应用数据不一致的问题，必须采用一个健壮的同步机制。最佳实践是采用**推送通知为主、定时轮询为辅**的混合策略。

* **方案一：推送通知 (Push Notifications) \- 实时同步 (主策略)**  
  * **工作原理:** 为每个用户注册一个通知渠道。当用户在Google Drive中做出任何更改时，Google会立即向您的后端Webhook (/webhook/drive-changes)发送一个轻量级的“警报”。  
  * **响应流程:** 后端收到“警报”后，立即调用**Changes API**获取详细的变更列表（如文件删除、重命名），并同步更新应用的数据库和AI索引，从而实现近乎实时的界面刷新。  
* **方案二：定时轮询 (Periodic Polling) \- 保险与查漏补缺 (辅策略)**  
  * **工作原理:** 后端通过一个定时任务（例如每小时一次），主动调用**Changes API**，查询自上次检查以来的所有变更。  
  * **目的:** 作为一种保险机制，防止因网络问题等原因导致推送通知丢失，确保数据的最终一致性。

#### **5\. 安全信息库：客户端加密与零知识架构**

为了安全地存储用户的网站注册信息等敏感数据，我们必须采用**客户端加密 (Client-Side Encryption)方案，构建一个零知识 (Zero-Knowledge)** 架构。这意味着您的后端服务器永远不会接触到用户未加密的敏感数据或其保护密码，从而最大限度地保障用户隐私。

* **加密与保存流程:**  
  1. **前端输入:** 用户在界面输入敏感信息（如网站密码）和自定义的“主密码”。  
  2. **密钥派生:** 前端代码使用标准的密钥派生函数 (如 **PBKDF2**)，将用户的“主密码”和一个随机生成的“盐”(Salt)混合运算，派生出一个无法反向推导的加密密钥。  
  3. **客户端加密:** 使用行业标准的 **AES-256-GCM** 算法，在用户的浏览器中用派生出的密钥对敏感信息进行加密，生成密文。  
  4. **打包上传:** 前端将加密后的**密文**和公开的\*\*“盐”\*\*打包成一个文件，发送给后端。  
  5. **后端存储:** 后端将这个完全加密的文件存入用户的Google Drive，自身不保存任何解密所需的信息。  
* **解密与查阅流程:**  
  1. **获取文件:** 后端从Google Drive获取加密文件，并直接传给前端。  
  2. **前端解密:** 前端提示用户输入“主密码”，并重复上述的密钥派生过程。如果密码正确，就能在浏览器中成功解密并显示信息；如果密码错误，则解密失败。

#### **6\. AI智能搜索：核心技术实现 (混合策略)**

这是本应用最具挑战性也最有价值的部分。我们将采用一个智能的**混合策略 (Hybrid Strategy)**，根据任务的复杂度和成本效益，动态选择最合适的Gemini模型。

1. **文件内容提取与处理 (智能分诊):**  
   * **场景一：简单文件处理 (例如，仅上传图片/文档进行分类)**  
     1. **策略:** 调用更经济、更快速的模型，如 gemini-2.5-flash-preview-05-20。  
     2. **目的:** 以最低成本完成高频、重复性的信息提取和分类任务。  
   * **场景二：复杂多模态任务 (例如，上传图片并用语音指令操作)**  
     1. **策略:** 调用功能最强大的多模态模型，如 gemini-1.5-pro-preview-05-20。  
     2. **目的:** 利用其强大的上下文理解能力，一次性处理语音、图片等多种信息，大大降低开发复杂度和维护成本。  
2. **文本向量化与索引 (Indexing):**  
   * **文本分块 (Chunking):** 将提取出的长文本分割成较小的、有意义的文本块。  
   * **生成嵌入 (Embeddings):** 调用 **Gemini API** (可选择text-embedding系列模型以优化成本) 来生成文本的向量嵌入。  
   * **存储索引:** 将这些文本向量，连同它们所对应的原始文件ID和文本块内容，存储在一个专门的 **向量数据库 (Vector Database)** 中，例如 Pinecone, Weaviate 等。  
3. **AI知识库查询与结果生成:**  
   * **策略:** 这是核心付费功能，必须使用强大的 gemini-1.5-pro-preview-05-20 模型。  
   * **流程:**  
     1. **查询向量化:** 将用户的自然语言问题转换为向量。  
     2. **相似性搜索:** 在向量数据库中检索最相关的文档片段。  
     3. **答案生成:** 将检索到的片段作为上下文，喂给Pro模型，生成一个精准、人性化的回答，而不仅仅是返回文件列表。

### **三、 附录：如何开通并配置 Google Drive API**

这是整个项目的关键第一步，主要在 **Google Cloud Console** 中完成。

#### **步骤 1：创建或选择一个 Google Cloud 项目**

所有 API 的使用都必须归属于一个“项目”。

1. 前往 [**Google Cloud Console**](https://console.cloud.google.com/)。  
2. 点击页面顶部的项目选择器，然后点击 **"新增专案" (New Project)**。  
3. 为您的项目命名（例如：“个人文件管理系统”），然后点击 **"建立" (Create)**。

#### **步骤 2：启用 Google Drive API**

创建好项目后，您需要告诉 Google，这个项目将要使用 Google Drive API。

1. 在左侧的导航菜单中，找到并选择 **"API 和服务" (APIs & Services) \> "程式库" (Library)**。  
2. 在搜索框中输入 “**Google Drive API**” 并搜索。  
3. 在搜索结果中点击 “Google Drive API”。  
4. 在打开的页面中，点击蓝色的 **"启用" (Enable)** 按钮。

#### **步骤 3：设定 OAuth 同意画面 (OAuth Consent Screen)**

当您的用户登录并授权您的应用时，他们看到的授权许可界面就是在这里配置的。

1. 在左侧导航菜单中，选择 **"API 和服务" (APIs & Services) \> "OAuth 同意画面" (OAuth consent screen)**。  
2. 选择用户类型 **"外部" (External)**，然后点击 **"建立" (Create)**。  
3. 填写必要信息：应用程式名称、使用者支援电子邮件、开发人员联络资讯。  
4. 点击 **"储存并继续" (Save and Continue)**。  
5. 在 **"范围" (Scopes)** 页面，点击 **"新增或移除范围" (Add or Remove Scopes)**。根据您的系统功能，至少需要选择 .../auth/drive 权限。  
6. 选择完范围后，点击 **"更新" (Update)**，然后点击 **"储存并继续" (Save and Continue)**。  
7. 在 **"测试使用者" (Test users)** 页面，添加您自己的 Google 帐户作为测试用户。  
8. 点击 **"储存并继续" (Save and Continue)**，然后返回信息中心。

#### **步骤 4：建立凭证 (Credentials)**

获取您的应用用来向 Google “证明自己身份” 的钥匙，也就是 **客户端ID (Client ID)** 和 **客户端密钥 (Client Secret)**。

1. 在左侧导航菜单中，选择 **"API 和服务" (APIs & Services) \> "凭证" (Credentials)**。  
2. 点击页面顶部的 **"+ 建立凭证" (+ Create Credentials)**，然后选择 **"OAuth 用户端 ID" (OAuth client ID)**。  
3. 在 **"应用程式类型" (Application type)** 下拉菜单中，选择 **"网页应用程式" (Web application)**。  
4. 在 **"已授权的重新导向 URI" (Authorized redirect URIs)** 部分，点击 **"新增 URI"**，填入您后端服务中用于处理 Google 授权回调的 API 地址 (例如: https://your-backend-service.com/auth/google/callback)。  
5. 点击 **"建立" (Create)**。

完成后，系统会显示您的 **"用户端 ID" (Client ID)** 和 **"用户端密钥" (Client Secret)**。请务必将它们安全地复制并存储在您的后端服务器上，**切勿**暴露在前端代码中。

### **四、 系统部署与扩展**

* **云平台选择:** 强烈建议将整个应用部署在 **Google Cloud Platform (GCP)** 上，因为它可以与Google Drive API以及Vertex AI等服务无缝集成，减少网络延迟并简化权限管理。可以使用 **Google App Engine** 或 **Cloud Run** 来部署后端服务，使用 **Cloud Storage** 存储临时文件。  
* **成本考量:**  
  * **Google Drive API:** 本身免费，但有使用频率的配额限制。  
  * **Gemini API:** 核心成本来源。通过我们讨论的混合策略，可以在提供强大功能的同时，将成本控制在合理范围内。成本将由您的订阅费（付费用户）或用户自己（BYOK用户）承担。  
* **可扩展性:** 架构设计应考虑未来的可扩展性，例如支持更多云存储服务（如Dropbox, OneDrive），或集成更丰富的AI功能（如文档自动分类、摘要生成等）。

### **五、 总结**

构建一个基于Google Drive的个人文件管理系统，其核心在于安全可靠的用户授权、流畅稳定的文件操作体验，以及颠覆性的AI智能搜索能力。通过采用OAuth 2.0, 现代前后端框架, 并深度整合Google Drive API与Google Gemini API，特别是通过**智能的混合策略**来调用不同模型、**健壮的同步机制**来保证数据一致性、以及**客户端加密**来保障敏感数据安全，您的应用将能真正帮助用户从繁杂的文件管理中解脱出来，进入一个智能、高效、安全的个人数据管理新时代。

# **开发启动规范文档**

以下文档旨在将上述架构蓝图转化为可执行的开发任务和规范，确保团队成员与AI Agent能够高效、协同地进行模块化开发。

### **六、 项目任务板 (Project Task Board)**

此为项目任务的宏观分解，用于跟踪进度和分配资源。

* **史诗任务：用户认证与状态管理 (Epic: Auth & User State)**  
  * **后端:** 实现Google OAuth 2.0的完整授权码流程。  
  * **后端:** 设计并实现用户表，包含用户状态（试用、BYOK、付费）和用量统计。  
  * **前端:** 创建登录/登出按钮和逻辑。  
  * **前端:** 根据用户状态，动态显示或隐藏特定UI元素。  
* **史诗任务：核心文件管理 (Epic: Core File Management)**  
  * **后端:** 开发/files系列API，实现对Google Drive的CRUD（增删改查）操作。  
  * **前端:** 开发文件/文件夹浏览器组件（列表/网格视图）。  
  * **前端:** 实现文件上传、重命名、删除、移动的交互逻辑和UI。  
  * **前端:** 实现文件分享链接的生成和权限设置界面。  
* **史诗任务：安全信息库 (Epic: Secure Vault)**  
  * **前端:** 实现客户端AES-256加密/解密模块 (使用crypto-js或类似库)。  
  * **前端:** 开发安全信息库的表单和主密码输入/验证界面。  
  * **后端:** 开发/vault系列API，仅负责加密文件的存取，不接触明文。  
* **史诗任务：AI智能功能 (Epic: AI Features)**  
  * **后端(AI Agent):** 编写调用Gemini API的通用服务模块。  
  * **后端(AI Agent):** 实现智能分诊逻辑，根据任务类型选择gemini-flash或gemini-pro。  
  * **后端(AI Agent):** 实现文本向量化和与向量数据库的交互逻辑。  
  * **前端:** 开发AI搜索栏组件，并处理异步返回的结果。  
  * **前端:** 开发BYOK模式下的API Key输入与本地安全存储界面。  
* **史诗任务：数据同步 (Epic: Data Sync)**  
  * **后端:** 搭建并配置/webhook/drive-changes端点，用于接收Google的推送通知。  
  * **后端:** 开发处理Changes API响应的逻辑，并更新数据库和AI索引。  
  * **后端:** 设置后台定时任务，作为同步的保险机制。

### **七、 API接口规范 (OpenAPI 核心定义)**

这是前后端团队的“契约”，定义了所有API的请求和响应格式。

openapi: 3.0.0

info:

  title: 个人文件管理系统 API

  version: 1.0.0

paths:

  /auth/google:

    get:

      summary: 重定向到Google进行OAuth授权

      responses:

        '302':

          description: 重定向到Google授权页面。

  /auth/google/callback:

    get:

      summary: Google授权后的回调地址

      parameters:

        \- name: code

          in: query

          required: true

          schema:

            type: string

      responses:

        '200':

          description: 授权成功，返回JWT令牌。

          content:

            application/json:

              schema:

                type: object

                properties:

                  token:

                    type: string

        '401':

          description: 授权失败。

  /vault/save:

    post:

      summary: 保存一个加密的安全信息文件

      security:

        \- bearerAuth: \[\]

      requestBody:

        required: true

        content:

          application/json:

            schema:

              type: object

              properties:

                encryptedContent:

                  type: string

                  description: "AES-256-GCM加密后的密文"

                salt:

                  type: string

                  description: "用于PBKDF2密钥派生的盐"

                fileName:

                  type: string

                  description: "在Google Drive中保存的文件名"

      responses:

        '201':

          description: 文件创建成功。

          content:

            application/json:

              schema:

                type: object

                properties:

                  fileId:

                    type: string

        '400':

          description: 请求体格式错误。

  /search:

    post:

      summary: 执行AI知识库搜索

      security:

        \- bearerAuth: \[\]

      requestBody:

        required: true

        content:

          application/json:

            schema:

              type: object

              properties:

                query:

                  type: string

                  description: "用户的自然语言查询"

      responses:

        '200':

          description: 返回AI生成的答案。

          content:

            application/json:

              schema:

                type: object

                properties:

                  answer:

                    type: string

                  sources:

                    type: array

                    items:

                      type: object

                      properties:

                        fileId:

                          type: string

                        fileName:

                          type: string

### **八、 数据库设计 (ER图与数据字典)**

#### **1\. 表结构**

* **Users**  
* **User\_API\_Keys**  
* **Usage\_Stats**

#### **2\. 数据字典**

**Table:** Users

| Column Name | Data Type | Constraints | Description |
| :---- | :---- | :---- | :---- |
| id | UUID | PRIMARY KEY | 内部唯一用户ID |
| google\_id | VARCHAR(255) | UNIQUE, NOT NULL | 用户的Google Account ID |
| email | VARCHAR(255) | UNIQUE, NOT NULL | 用户的邮箱 |
| status | ENUM | NOT NULL, DEFAULT 'trial' | 用户状态 ('trial', 'byok', 'paid') |
| google\_refresh\_token | TEXT | NOT NULL | 加密存储的Google Refresh Token |
| created\_at | TIMESTAMP | NOT NULL, DEFAULT NOW() | 创建时间 |
| updated\_at | TIMESTAMP | NOT NULL, DEFAULT NOW() | 更新时间 |

**Table:** User\_API\_Keys

| Column Name | Data Type | Constraints | Description |
| :---- | :---- | :---- | :---- |
| id | UUID | PRIMARY KEY | 密钥记录ID |
| user\_id | UUID | FOREIGN KEY (Users.id) | 关联的用户ID |
| gemini\_api\_key | TEXT | NOT NULL | 加密存储的用户自己的Gemini API Key |
| created\_at | TIMESTAMP | NOT NULL, DEFAULT NOW() | 创建时间 |

**Table:** Usage\_Stats

| Column Name | Data Type | Constraints | Description |
| :---- | :---- | :---- | :---- |
| user\_id | UUID | PRIMARY KEY, FOREIGN KEY (Users.id) | 关联的用户ID |
| trial\_files\_processed | INTEGER | NOT NULL, DEFAULT 0 | 试用期已处理的文件数 |
| trial\_queries\_made | INTEGER | NOT NULL, DEFAULT 0 | 试用期已进行的AI查询次数 |
| last\_reset\_at | TIMESTAMP | NULL | 上次用量重置时间（用于付费订阅） |

### **九、 开发与运维手册 (DevOps Handbook)**

#### **1\. 源码管理策略 (Git Workflow)**

* **主分支:** main (生产环境，受保护), develop (开发主线)。  
* **辅助分支:**  
  * feature/xxx: 开发新功能。  
  * bugfix/xxx: 修复Bug。  
  * release/vx.x.x: 准备发布新版本。  
* **提交流程:** 所有代码必须通过Pull Request合并到develop，并需要至少一名其他成员进行Code Review。

#### **2\. 环境搭建指南**

* **后端:** Node.js v20.x, pnpm包管理器。  
* **前端:** Node.js v20.x, pnpm包管理器, React (Vite)。  
* **数据库:** PostgreSQL v15+。  
* **工具:** 提供docker-compose.yml文件，用于一键启动本地开发所需的数据库和向量数据库实例。

#### **3\. 环境变量管理**

* 使用.env文件管理本地开发环境变量。  
* .env.example文件将作为模板，列出所有必需的环境变量，但不包含敏感值。  
* **核心变量:** GOOGLE\_CLIENT\_ID, GOOGLE\_CLIENT\_SECRET, DATABASE\_URL, JWT\_SECRET, ENCRYPTION\_KEY\_FOR\_TOKENS, OUR\_GEMINI\_API\_KEY。  
* **生产环境:** 所有密钥和敏感变量必须通过GCP Secret Manager进行管理。

#### **4\. CI/CD 流程 (持续集成/持续部署)**

* **触发器:** 向develop分支的推送会触发自动化测试和构建，并部署到Staging环境。  
* **Staging环境:** 用于内部测试和QA。  
* **生产部署:** 从develop创建release分支，测试无误后合并到main分支，触发生产环境的部署。  
* **工具栈:** GitHub Actions, Google Cloud Build, Google Cloud Run。

# **十、 模块化开发深度设计 (Module-Level Deep Dive)**

本章节将由各开发组长，根据已分配的任务卡，对核心模块进行更深层次的技术设计和伪代码实现，作为编程工作的直接指导。

### **角色：整合组长 (Integration Lead)**

我的职责是确保所有模块能顺利粘合，并为团队提供稳定、一致的开发与测试环境。

* **任务1：搭建CI/CD基础流水线**  
  * **行动:** 我将立即在GitHub Actions中创建两个工作流文件：develop-pipeline.yml和main-pipeline.yml。  
  * develop-pipeline.yml**:**  
    * 触发条件：on: push: branches: \[ develop \]  
    * 步骤：  
      1. 检出代码。  
      2. 安装Node.js和pnpm。  
      3. 执行pnpm install安装依赖。  
      4. 执行pnpm test运行后端和前端的单元测试。  
      5. (如果测试通过) 构建Docker镜像。  
      6. 推送到Google Artifact Registry。  
      7. 部署到Google Cloud Run上的**Staging环境**。  
  * main-pipeline.yml**:** 流程类似，但触发条件为on: push: branches: \[ main \]，并部署到**Production环境**。  
* **任务2：定义并提供前端模拟服务 (Mock Service)**  
  * **目的:** 解耦前后端开发，让前端无需等待后端API即可开工。  
  * **行动:** 我将在前端项目中创建一个src/mocks目录，并使用msw (Mock Service Worker)库。  
  * src/mocks/handlers.js **(伪代码):**

import { rest } from 'msw';

export const handlers \= \[

  // 模拟获取文件列表

  rest.get('/api/files', (req, res, ctx) \=\> {

    return res(

      ctx.status(200),

      ctx.json(\[

        { id: '1', name: 'Invoice-2025.pdf', type: 'file', modifiedTime: '2025-08-03T10:00:00Z' },

        { id: '2', name: 'Travel Plans', type: 'folder', modifiedTime: '2025-08-02T15:30:00Z' },

      \])

    );

  }),

  // 模拟AI搜索

  rest.post('/api/search', (req, res, ctx) \=\> {

    const { query } \= req.body;

    return res(

      ctx.status(200),

      ctx.json({

        answer: \`关于查询 "${query}"，我找到了相关旅行记录文件。\`,

        sources: \[{ fileId: '2', fileName: 'Travel Plans' }\]

      })

    );

  }),

\];

*   
  * **交付:** 我会确保这个模拟服务在开发模式下自动启动，前端开发者可以立即调用这些API并获得符合规范的假数据。

### **角色：前端开发者 (Frontend Developer)**

我的任务是构建一个响应迅速、用户友好且安全的界面。

* **任务1：项目结构与状态管理**  
  * **框架:** React \+ Vite。  
  * **组件结构:** 我会将UI拆分为可复用的组件：  
    * components/FileBrowser/: 包含FileGrid.jsx, FileList.jsx, FileItem.jsx。  
    * components/Navbar/: 包含UserProfile.jsx, Searchbar.jsx。  
    * components/modals/: 包含VaultModal.jsx, ShareModal.jsx。  
  * **状态管理:** 我选择使用 **Zustand**，因为它轻量、简单且无模板代码。  
    * stores/userStore.js**:** 管理用户信息、登录状态、用户status ('trial', 'byok', 'paid')。  
    * stores/filesStore.js**:** 管理当前目录的文件列表、加载状态、错误信息。  
    * stores/vaultStore.js**:** 管理安全信息库的加密/解密逻辑和状态。  
* **任务2：实现安全信息库的客户端加密 (Secure Vault)**  
  * **库:** 我将使用crypto-js库。  
  * stores/vaultStore.js **(伪代码):**

import CryptoJS from 'crypto-js';

const encryptData \= (data, masterPassword) \=\> {

  const salt \= CryptoJS.lib.WordArray.random(128 / 8).toString();

  // 使用PBKDF2派生密钥，迭代次数至少10000次

  const key \= CryptoJS.PBKDF2(masterPassword, salt, { keySize: 256 / 32, iterations: 10000 });

  const iv \= CryptoJS.lib.WordArray.random(128 / 8);

  const encrypted \= CryptoJS.AES.encrypt(JSON.stringify(data), key, {

    iv: iv,

    mode: CryptoJS.mode.GCM, // GCM提供认证加密

    padding: CryptoJS.pad.Pkcs7

  });

  // 将盐、IV和密文组合在一起返回

  return {

    salt: salt,

    encryptedContent: iv.toString() \+ encrypted.toString() 

  };

};

*   
  * **流程:** 在VaultModal.jsx组件中，当用户点击“保存”时，调用此encryptData函数，然后将返回的对象通过API发送到后端/vault/save。

### **角色：后端开发者 (Backend Developer)**

我的任务是构建稳定、安全且高效的后端服务。

* **任务1：实现用户认证与会话管理**  
  * **库:** jsonwebtoken (JWT), bcrypt (用于加密数据库中的敏感信息)。  
  * /auth/google/callback **(伪代码):**

async (req, res) \=\> {

  const { code } \= req.query;

  // 1\. 用code从Google换取access\_token和refresh\_token

  const { tokens } \= await oauth2Client.getToken(code);

  // 2\. 用access\_token获取用户信息（google\_id, email）

  const googleUser \= await getGoogleUserInfo(tokens.access\_token);

  // 3\. 查找或创建本地用户

  let user \= await User.findOne({ where: { google\_id: googleUser.id } });

  if (\!user) {

    user \= await User.create({

      google\_id: googleUser.id,

      email: googleUser.email,

      // 使用bcrypt加密refresh\_token再存入数据库

      google\_refresh\_token: await bcrypt.hash(tokens.refresh\_token, 10),

      status: 'trial'

    });

  }

  // 4\. 生成JWT令牌，包含我们的内部user.id和status

  const jwtToken \= jwt.sign({ userId: user.id, status: user.status }, process.env.JWT\_SECRET, { expiresIn: '1h' });

  // 5\. 返回JWT给前端

  res.json({ token: jwtToken });

}

*   
* **任务2：实现数据同步Webhook**  
  * /webhook/drive-changes **(伪代码):**

async (req, res) \=\> {

  // 1\. 验证请求是否来自Google (通过检查HTTP头)

  if (\!isRequestFromGoogle(req.headers)) {

    return res.status(403).send('Forbidden');

  }

  // 2\. 从请求头中获取受影响的用户ID

  const userId \= getUserIdFromHeaders(req.headers);

  // 3\. 立即响应Google，防止超时

  res.status(200).send(); 

  // 4\. 异步触发一个后台任务来处理该用户的变更

  //    这很重要，避免阻塞Webhook响应

  await processDriveChangesForUser(userId); 

}

* 

### **角色：AI Agent开发者 (AI Agent Developer)**

我的任务是封装所有与Gemini的交互，并实现智能策略。

* **任务1：创建Gemini服务模块**  
  * services/geminiService.js **(伪代码):**

import { GoogleGenerativeAI } from "@google/generative-ai";

// 获取API Key的逻辑

const getApiKey \= (user) \=\> {

  if (user.status \=== 'byok' && user.apiKey) {

    return user.apiKey; // 使用用户自己的Key

  }

  return process.env.OUR\_GEMINI\_API\_KEY; // 使用我们自己的Key

};

// 智能分诊与调用函数

export const processFileContent \= async (file, user, instruction \= "请分类并提取此文件的关键信息。") \=\> {

  const apiKey \= getApiKey(user);

  const genAI \= new GoogleGenerativeAI(apiKey);

  // 根据任务复杂度选择模型

  let model;

  if (hasComplexInstruction(instruction) || file.type \=== 'multimodal') {

    model \= genAI.getGenerativeModel({ model: "gemini-1.5-pro-preview-05-20" });

  } else {

    model \= genAI.getGenerativeModel({ model: "gemini-2.5-flash-preview-05-20" });

  }

  const result \= await model.generateContent(\[instruction, file.data\]);

  return result.response.text();

};

*   
* **任务2：实现AI知识库查询 (RAG)**  
  * services/knowledgeBaseService.js **(伪代码):**

import { getEmbeddings } from './embeddingService';

import { vectorDB } from './vectorDBClient';

import { processFileContent } from './geminiService';

export const searchKnowledgeBase \= async (query, user) \=\> {

  // 1\. 将用户查询向量化

  const queryVector \= await getEmbeddings(query, user);

  // 2\. 从向量数据库检索相关文档片段

  const relevantChunks \= await vectorDB.search(queryVector, { topK: 5 });

  // 3\. 构建一个丰富的Prompt

  const prompt \= \`

    根据以下背景信息，请回答用户的问题。

    问题: "${query}"

    背景信息:

    ${relevantChunks.map(chunk \=\> \`- ${chunk.text}\`).join('\\n')}

  \`;

  // 4\. 调用强大的Pro模型进行回答

  const answer \= await processFileContent({ type: 'text', data: prompt }, user, "请根据背景信息回答问题。");

  return {

    answer: answer,

    sources: relevantChunks.map(chunk \=\> ({ fileId: chunk.fileId, fileName: chunk.fileName }))

  };

}

* 

